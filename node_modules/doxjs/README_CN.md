# DoxJS

`DoxJS`是一个简单的状态管理工具，它使用`Typescript`编写。

## 文档

* [English document](https://github.com/doxjs/doxjs/)
* 中文文档

## 为什么使用doxjs

事实上，现在有许多的状态管理工具，例如著名的`redux`和`mobx`。如果你曾经使用过它们，那么你应该很清楚它们的缺点。

* `redux`是一个著名的状态管理工具，它沿袭了`Flux`的思想。`redux`需要手动编写`reducer`，这个过程虽然很简单，但是却显得很复杂。
* `Mobx`就是为了解决以上问题所产生的全新工具，它可以响应式地检测变化，并且做出反应。`Mobx`提供了大量的API，例如`observable`、`autorun`之类的。`Mobx`看起来很简单，但是它所提供的功能却十分庞大，`Mobx`推荐使用装饰器语法，这个语法正处于早期阶段，看起来并不是那么友善（事实上，如果你曾经开发java类程序，例如Android APP，那么你会觉得十分熟悉）。除此之外，`Mobx`数据与视图之间的关系并非十分清晰，它的数据变化会直接触发相关事件。对于简单的数据程序，这种变化十分令人舒服。但是对于需要长期维护的大型程序，这种方式会使得程序的数据走向变得十分复杂。

`doxjs`正是为了解决这些痛点所诞生的。

## 一些建议
* 如果你更喜欢`Flux`的思想，那么毫无疑问，`redux`是最佳选择
* 如果你在使用`Vue.js`，那么官方提供的`Vuex`或许更加适合你
* 如果你喜欢装饰器的语法，`Mobx`是一个不错的选择
* 如果你没什么特别的想法，那么`doxjs`是你的不二之选

## 安装
### yarn

```shell
yarn add doxjs
```

### npm
```shell
npm install doxjs
```
## 术语
`listener`用于监听数据变化，在对应数据变化的时候会自动调用。`action`用于产生数据变化。`listener`中不应该发生数据变化，`action`中不应该监听数据变动。

## API

### dox = new DoxJS<T>(target: T extends object);
创建一个dox实例，值得注意的是，`target`需要是一个`object`。

### dox.observe(): DoxProxy;
返回一个代理对象，这个代理对象其实就是`subscribe`的回调函数所接受的参数。你完全可以把它当做`target`对待。在`DoxProxy`在对数据进行更改，`DoxJS`会智能地调用那些依赖了（或者说使用了）这些变量的回调函数。此外，`DoxJS`对数组的几个方法进行了想要式子处理，你可以在`core.ts`里查看所有的变异数组方法。如果你需要其他的遍历方法，那么请手动调用`Array.prototype`上的方法。

另外，`DoxProxy`可以响应数据的变化，需要注意的是，`DoxJS`对于数据变化的认知应该是类型相同的，比如你不应该将一个`string`赋值成为`number`。

最后一点需要注意的地方是，`DoxJS`不会响应属性的添加、删除。因此，使用`delete`是一个不好的操作。

### dox.bindActions(actions: { [key: string]: Function })

绑定一些`actions`。这些绑定的`actions`会在`dispatch`是调用。`actions`应该是一些函数，这些函数第一个参数是`store`，后面的参数是你在`dispatch`时传递的参数。
```js

    let dox = new DoxJS({
        value: 0
    });
    let store = dox.observe();

    const actions = {
        inc: (store, value = 1) => {
            store.value += value
        },
        dec: (store, value = 1) => {
            store.value -= value;
        }
    }

    dox.bindActions(actions);
    dox.subscribe((store) => {
        //display value
        console.log(store.value);
    });

    dox.dispatch("inc", 2); //store.value is 2 now

    dox.dispatch("dec", 3);// store.value is -1 now

```

### dox.dispatch(action: string, ...args: any[])

配合`bindActions`使用，调用已经绑定的`actions`。

### dox.bindListeners(listeners: { [key: string]: (store: T) => void });
用于绑定`listener`， 这个方法需要配合`subscribe`来使用，请看下面的例子：
```js

const listeners = {
    display: function(store) {
        document.appendChild(`<h3>${store.value}</h3>`);
        // `this` is related to the third parameter of `subscribe`
        // in this example, `this` is { word: "hello world!" }
        console.log(this);
    }
}

dox.bindListeners(listeners);

// now `subscribe` a listener
dox.subscribe('display', false, {
    word: "hello world!"
});

```
需要注意的是，在上面这个例子中，`display`不应该用箭头函数。这是因为doxjs内部使用了`Function.prototype.bind`来绑定`this`变量，而箭头函数不起作用。

### dox.subscribe(callback: (store: T) => void, excuteLater: boolean = false);
`dox`是上面所创建的`DoxJS`实例，`subscribe`用于监听一个事件。它接收两个参数。第一个参数是一个回调函数，这个回调函数需要接收一个`store`作为参数。`store`与`target`具有相似的数据形式，`target`也就是你在实例化的时候传递的参数。当然，`store`与`target`是不一样的，但是你完全可以把它们当做同一个来对待。

这个回调函数里面，你如果使用了`store`参数上的某个变量，那么当这个变量发生改变时，`doxjs`会智能地调用这个回调函数，并且传递变化后的`store`给它。

第二个参数是一个布尔型变量，从他的名字你应该不难发现，它是控制这个回调函数在初始化的时候会不会立即执行的。为什么要这样呢？这是因为`doxjs`的内部，在`subscribe`的时候，`doxjs`需要确定你传递的`callback`中使用了`store`上的哪些变量，所以它必须运行一下你传递进入的`callback`。如果你不想立即执行，只需要在`subscribe`时，传入第二个参数为`true`，那么`subscribe`会返回一个函数，当你调用这个函数的时候，再执行对应的回调函数。也就是说，不传递第二个参数实际上和将第二个参数设置为`true`，并且立即执行它所返回的函数是一样的作用，并没有什么特殊的地方。这是出于性能考虑的，至于原因，你需要了解`React`的渲染步骤。你完全可以忽略这个参数。给个例子方便理解：
```js
    let dox = new DoxJS({
        value: 0
    });

    dox.subscribe((store) => {
        console.log(store.value);
    }); // it will run immediately


    // it's same with codes above

    let fn = dox.subscribe((store) => {
        console.log(store.value);
    }, true); // it will not run immediately unless you call fn

    fn();

```
### dox.subscribe<C>(listenerName: string, excuteLater: boolean = false, context?: C);

这个API需要配合`bindListeners`来使用，你可以查看`bindListeners`的例子来了解它的使用。区别于`subscribe`的另一种用法，这种调用方式需要提供第三个参数，也就是对应`listener`中`this`变量。

`subscribe`的两种方式本质上是一致的，无论第一个参数是回调函数还是字符串，本质上子内部最后都是`subscribe`一个回调函数。之所以提供第二种调用方式，这是为了使得体验更好。

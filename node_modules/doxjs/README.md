# DoxJS

`DoxJS` is a very easy state management, it's written in `Typescript`.

## document

* 英文文档
* [中文文档](https://github.com/doxjs/doxjs/blob/master/README_CN.md)

## why doxjs?

In fact, there are many state managements. Such as `redux` and `mobx`. If you once used one of them, you should know clearly about their shortcomings.

* `redux` is one of the best state managements. But once you used it ever, you would feel tired about it. Coding `reducer` is easy but complex, nobody likes something complex.

* The emergence of `Mobx` is to solve the above problems. So is `Mobx` perfect? No. `Mobx` offers many Functions, such as `observable` `autorun`. `Mobx` looks very simple in usage. But at the same time, Mobx provides more functionality to make it bloated. For the general developers, many functions are not necessary. In addition,  the decorator syntax  is not friendly to the general developers. In addition, the relationship between data and the view is not very clear in `Mobx`, and its data changes will trigger the relevant events directly. For simple programs, this change is very comfortable. But for large programs that require long-term maintenance, this approach can make the data movement of the program very complicated.

## before using doxjs

* If you prefer the Flux's concepts, and tend to be logical, clear operating logic, and a flat data structure. `Redux` is a better choice to you.
* If you are using `Vue`, `Vuex` is solid choice.
* If you prefer decorator syntax, `Mobx` is the best choice.
* If you need a easy management, don't hesitate, just use `DoxJS`.

## Install

### yarn

```shell
yarn add doxjs
```

### npm
```shell
npm install doxjs
```

## Term

`listener` is used to monitor changes in data, and `listener` is called when the data changes. `action` is used to generate data changes. In general, data changes should not be produced in `listener`, and also in `action`, data should not be monitored.

## API

### dox = new DoxJS<T>(target: T extends object);

Generating a `DoxJS` instance, you should notice that  `target` should be an `object`, not `string`,`array`, etc.

### dox.observe(): DoxProxy;

`dox.observe()` will return a DoxProxy instance. Say again, you just need to treat `DoxProxy` as `target` which you passed to `new DoxJS(target)`.

When you change the variables on the `DoxProxy`, the subscriped function that uses these variables will be called.

For arrays, we provide a partial mutation method, which you can see in `core.ts`. You can manually call `Array.prototype` for mutable methods that are not provided.


### dox.bindActions(actions: { [key: string]: Function })

`dox.bindActions(actions)` is using for binding some actions. This API needs to be used in conjunction with `dispatch`. Focus on below example.
```js

    let dox = new DoxJS({
        value: 0
    });
    let store = dox.observe();

    const actions = {
        inc: (store, value = 1) => {
            store.value += value
        },
        dec: (store, value = 1) => {
            store.value -= value;
        }
    }

    dox.bindActions(actions);
    dox.subscribe((store) => {
        //display value
        console.log(store.value);
    });

    dox.dispatch("inc", 2);//store.value is 2 now

    dox.dispatch("dec", 3);// store.value is -1 now

```

### dox.dispatch(action: string, ...args: any[])

After you have called `dox.bindActions`, you can use `dispatch` to dispatch an action with some argumets. See example above. First parameter is the name of the action, followed by optional parameters. These parameters will be passed to the specified action event.

`DoxProxy` can only be obtained by `dox.observe()`. `dox` is the instance of `DoxJS`.


### dox.bindListeners(listeners: { [key: string]: (store: T) => void });

Using for binding listeners. This API needs to be used in conjunction with `subscribe`. See below example:
```js

const listeners = {
    display: function(store) {
        document.appendChild(`<h3>${store.value}</h3>`);
        // `this` is related to the third parameter of `subscribe`
        // in this example, `this` is { word: "hello world!" }
        console.log(this);
    }
}

dox.bindListeners(listeners);

// now `subscribe` a listener
dox.subscribe('display', false, {
    word: "hello world!"
});

```
Something you should know is that `display` shouldn't be an arrow function. Why? Because dox uses `Function.prototype.bind` to apply `this`, but arrow function can't redefine `this`.


### dox.subscribe(listener: {(store: T) => void}, excuteLater: boolean = false);

`subscribe` a `listener`. `listener` should be an callback function. When the callback function is called, it will accept a `DoxProxy` as parameter. `DoxProxy` is same as `target`, but `DoxProxy` is redefined, you needn't know how it works. You just need treat `DoxProxy` as `target` which you passed to `new DoxJS(target)`. When will the callback function be called? When the dependent variable in the callback function changes.

`excuteLater` is a boolean, it was set up as `false` by default. If you pass `excuteLater` as `true`, `subscribe` will return a function. You can manually call the returned function. So why keep this parameter? It's easy to understand. Because when you `subscribe` a function, this function will be called immediately by default. Why? Because DoxJS needs to determine which variables are referenced in current subscribed function, so that it can be called again when these variables change.

```js
    let dox = new DoxJS({
        value: 0
    });

    dox.subscribe((store) => {
        console.log(store.value);
    }); // it will run immediately


    // it's same with codes above

    let fn = dox.subscribe((store) => {
        console.log(store.value);
    }, true); // it will not run immediately unless you call fn

    fn();

```


### dox.subscribe<C>(listenerName: string, excuteLater: boolean = false, context?: C);

This API needs to be used in conjunction with `bindListeners`.

There are two methods of calling `subscribe`. If first parameter is an callback function, it means that you subscribe a listener. If first parameter is a string, `subscribe` will try to search the callback function that corresponds to this `listenerName`. Where to search it? That's the useage of `bindListeners`.

The third parameter is using for binding context for callback function. It is valid only when the first parameter is `ListenerName`. This parameter works when you want to use the `this` variable in the callback function. See example of `bindListeners`.
